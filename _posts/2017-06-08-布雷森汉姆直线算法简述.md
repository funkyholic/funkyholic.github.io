---
layout: post
date:   2017-06-08
categories: programming
tags: computer-graphics algorithm

---



# 布雷森汉姆直线算法简述
![](http://o8e9d1ezz.bkt.clouddn.com/14864341830146.jpg)

已知直线上两点A(x0,y0), B(x1,y1)可知直线一般式方程(隐式)为:
$f(x,y) = (x_1-x_0)y + (y_0-y_1)x + x_0y_1 - x_1y_0 = 0$

设直线斜率为m:
Bresenham直线算法只支持0< m < 1的直线画线。如果要画的直线斜率不在这个范围，则通过对称映射(y=0,x=0,y=x,y=-x)翻转直线到0< m < 1的范围。算出要绘制的点的坐标后再反变换到原来的位置。

对于斜率m=0，或m=无限大的直线，只需要直接画相邻的点就可以，没有判断要画那个点的必要。

## 普通算法
![](http://o8e9d1ezz.bkt.clouddn.com/14864346587180.jpg)
 
假设点 $$(X_i,Y_i)$$ 已经绘制，现在需要判断下一个点究竟是绘制 $$(X_i+1,Y_i)$$ 还是 $$(X_i+1,Y_i+1)$$。
最直接的办法就是判断直线与 $$X_i+1$$ 轴交点距离两个像素多远，比较 $$d_2$$和 $$d_1$$。
如此一来就要计算浮点数，开销较大。


## 中间点算法 Midpoint Alg
改进普通算法

![](http://o8e9d1ezz.bkt.clouddn.com/14864348839247.jpg)


设 $$(X_i+1,Y_i)$$ 还是 $$(X_i+1,Y_i+1)$$ 的中间点为 $$M(X_i+1,Y_i+0.5)$$。
根据隐式直线公式:
f(M)>0 则M点在直线上面，那么直线距离下面的点较近，绘制 $$(X_i+1,Y_i)$$。
f(M)<0 则M点在直线下面，那么直线距离下面的点较近，绘制 $$(X_i+1,Y_i+1)$$。
f(M)=0 则M点在直线上，任选一个绘制。

中间点算法在计算f(M)时存在浮点运算，因为M的y坐标小数位是0.5。


## 增量改进算法 Incremental
改进中间点算法
为了消除中间点算法中f(M)的浮点数计算:

![](http://o8e9d1ezz.bkt.clouddn.com/14864355237030.jpg)


设 $$D_c = f(M) = f(x+1,y+0.5)$$
在此图中可知$D_c < 0$
则x+2轴的中间点M'存在于(x+2,y)和(x+2,y+1)之间:  
$$D_n = f(M') = f(x+2,y+0.5)$$  
$$D_n = (y_0-y_1)(x+2) + (x_1-x_0)(y+0.5) + x_0y_1 - x_1y_0$$  
$$D_n = f(x+1,y+0.5) + (y_0-y_1)$$  
$$D_n = f(D_c) + (y_0-y_1)$$  


![](http://o8e9d1ezz.bkt.clouddn.com/14864355991439.jpg)


在此图中可知$D_c > 0$
则x+2轴的中间点M''存在于(x+2,y+1)和(x+2,y+2)之间:
$D_n = f(M') = f(x+2,y+1.5)$
$D_n = D_c + (y_0-y_1) + (x_1-x_0)$

算法:

```
y = y0
a = y0-y1
b = x1-x0
d = f(x0+1,y0+0.5)
for x = x0...x1:
	drawpoint(x,y)
	if d<0:
		y = y+1
		d = d+a+b
	else:	//d>0
		d = d+a
```

此处第一次计算d时依旧有浮点运算$y_0+0.5$，如果要绘制10亿条直线，那么就有10亿次浮点运算。

### 消除浮点运算
为了完全消除浮点运算。
我们可以计算2d
2d = 2*f(x0+1,y0+0.5) 
最终可以把0.5变成1
而乘以2并不会影响d和0的大小比较。

对于任意直线，我们要计算直线斜率
$m = (y_1-y_0)/(x_1-x_0)$
比如判断 0 < m < 1
则可以把分子乘到不等式两边，就不需要计算浮点值了。

