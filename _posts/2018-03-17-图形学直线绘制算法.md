# 图形学直线绘制算法  
数学模型中的直线是由所构成的，这里的点并没有尺寸定义。但是在光栅显示设备上，最小的单位为像素。像素是有尺寸的，用像素绘制一条直线，实际上是对直线的离散采样。在实际绘制过程中我们需要考虑要绘制哪个像素，才能够最接近直线方程。  
  
已知二维直线方程的参数表达式:  
y = kx + b  
给定直线的两个端点: $$(x_0, y_0)$$ 和 $$(x_1, y_1)$$ 我们就能求出斜率k和纵截距b。  
$$k = \frac{y_1-y_0}{x_1-x_0}$$  
$$b = y_0 - kx_0$$  
  
在此我们假设斜率 $$0<k<1$$，且  $$x_1>x_0$$ ，$$y_1>y_0$$。（其他情况可以通过坐标变换变成这种情况处理，再变回去。）  
  
在斜率 $$0<k<1$$的情况下，直线水平增幅比竖直方向增幅大，因此想要绘制正常的直线（看起来合理），同一垂直方向上不可能有连续两个像素点需要绘制。  

![Screen Shot 2018-03-16 at 22.46.56](http://o8e9d1ezz.bkt.clouddn.com/Screen Shot 2018-03-16 at 22.46.56.png)  
  
  
假设我们已经确定要绘制像素点$$(x_i, y_i)$$，现在需要确定下一个点绘制哪个，为了保证上一条原则，选择只有2个: $$(x_i+1, y_i)$$ 还是 $$(x_i+1, y_i+1)$$?  
直观的想法就是，直线离哪个点近就选哪个。  
  
![Screen Shot 2018-03-16 at 22.31.01](http://o8e9d1ezz.bkt.clouddn.com/Screen Shot 2018-03-16 at 22.31.01.png)  
  
如图，在已绘制 $$(x_i+3, yi+2)$$ 的情况下，需要判断在 $$X_i+4$$ 的位置画哪个点，是 $$(x_i+4, y_i+2)$$ 还是 $$(x_i+4, y_i+3)$$。  
  
  
## 普通直线求交算法  
对于每个x值，求唯一对应的y值以确定画哪个像素。  
即直接计算 $$y = kx + b$$与 $$x = x_i + 1$$ 交点的纵坐标 $$y' = k(x_i + 1) + b$$  
把 $$y'$$ 舍入到整数。  
这里 $$k(x_i+1)$$ 会产生浮点数的乘法运算，运算开销很高。  
  
```  
for x = x0 to x1:  
  y = round(f(x))  
  draw(x,y)  
```  
  
## DDA算法  
还是设0<k<1的情况。  
已知直线上点的性质: x每增加1，y增加k  
我们沿着x轴取样: $$(x_i, y_i)$$ 的下一个点是 $$(x_i+1, y_i+k)$$ 
y舍入为整数  
  
如果k>1，则以单位y轴取样: (可以以坐标变换的方式思考y=x)  
y每增加1，x增加1/k  
x舍入为整数  
  
如果斜率为负则递减就可以了。  
  
优点: 不需要做乘法  
缺点: 循环体内有浮点数加法，如果增量是浮点数，则对于较长线段，误差会逐渐累积。  
  
```  
dx = x1-x0;  
dy = y1-y0;  
k = dy/dx;  
draw(round(x_0), round(y_0))  
for x = x0+1 to x1:  
  y += k;  
  draw(round(x), round(y));  
```  
  
## 中间点算法（Midpoint Algorithm）  
  

![Screen Shot 2018-03-16 at 22.26.44](http://o8e9d1ezz.bkt.clouddn.com/Screen Shot 2018-03-16 at 22.26.44.png)  

  
已知直线上2点可得隐函数公式，所有在直线上的点满足:  
$$f(x, y) = (x_1-x_0)y + (y_0-y_1)x + x_0y_1 - x_1y_0 = 0$$ 
在此还是假设 $$x_0 < x_1$$ 并且斜率0<k<1。  
前面已经分析了，在已知 $$(x_i, y_i)$$ 被绘制的情况下，下一个要绘制的点只有2种选择: $$(x_i+1,y_i)$$ 还是 $$(x_i+1,y_i+1)$$  
这两个候选点的中间点为 $$M: (x_i+1,y_i+0.5)$$。  
  
如果  
f(M)>0 则M点在直线上面，那么直线距离下面的点较近，绘制 $$(X_i+1,Y_i)$$。  
f(M)<0 则M点在直线下面，那么直线距离下面的点较近，绘制 $$(X_i+1,Y_i+1)$$。  
f(M)=0 则M点在直线上，任选一个绘制。  
  
```  
y = y0;  
for x = x0 to x1:  
  draw(x, y)  
  if f(x+1, y+0.5) < 0:  
    y = y + 1  
```  
该算法沿x轴画点，每次绘制后根据函数f更新下一个点的y坐标值。  
并且由于浮点数精度问题，随着直线加长会累积误差。  
  
中间点算法在计算f(M)时存在浮点运算，因为M的y坐标小数位是0.5，开销很大，但是可以通过改进消除浮点运算。  
  
  
## 中间点算法改进: 增量算法（Increment）  
因为我们每次都是计算f(x+1, y+0.5)的值与0比较，其中x和y都是整数，而f(x,y)又有如下性质:  
$$f(x+1, y) =  f(x, y) + (y_0 - y_1) $$  
$$f(x+1, y+1) =  f(x, y) + (y_0 - y_1) + (x_1 - x_0) $$  
上面2个运算都是整数运算。  
因此其实只需要第一次算f(x+1, y+0.5)的值就可以了，后面的比较都用增量来计算。  
  
```  
y = y0  
d = f(x0+1, y0+0.5)  
for x = x0 to x1:  
  draw(x, y)  
  if d < 0:  
    y = y + 1  
    d = d + (y_0 - y_1) + (x_1 - x_0)  
  else:  
    d = d + (y_0 - y_1)  
```  
其中，$$(y_0 - y_1)$$ 和 $$(x_1 - x_0)$$ 都是常数，可以计算后放在一个变量中，避免在循环内反复计算。  
这样对于每条直线，只有开头的一次浮点数计算: d = f(x0+1, y0+0.5)  
如果绘制很多直线，比如上亿条，那就有上亿次浮点计算，还是有不少开销。  
  
为了完全消除浮点运算。  
我们可以计算2d  
2d = 2*f(x0+1,y0+0.5)   
最终可以把0.5变成1  
而乘以2并不会影响d和0的大小比较。  
  
  
## Bresenham算法  
Bresenham算法本质上和中间点算法是一样的。  
Bresenham用的是函数的参数公式，一般只能用于圆和直线。  
中间点利用了隐函数，算是Bresenham的泛化。  
  
还是在已确定绘制$(x_i, y_i)$的情况下  
考虑直线 y = kx + b 和 x = $$x_i + 1$$ 的交点的y坐标为  
$$y' = k(x_i + 1) + b$$  
我们需要计算y'到 $$y_i+1$$ 和 $$y_i$$的距离:   
$$d_{lower} = y' - y_i$$  
$$d_{upper} = y_i+1 - y'$$  
$$d = d_{lower} - d_{upper} = 2y' - 2y_i - 1$$  
如果d<0则选$$y_i$$，否则选 $$y_i+1$$  
  
为了消除浮点运算，在两边同时乘以 $$(x_1-x_0)$$，不影响符号:  
$$P_i = (x_1-x_0)d = 2(y_1-y_0)(x_i+1) - 2(x_1-x_0)y_i + c$$  
这里若 $$P_i < 0$$，则下一个点（标记为第i+1个点）绘制 $$(x_i+1, y_i)$$  
c是个常数项，我们后面要用增量算法把它约去，所以不需要算。  
$$P_{i+1} - P_i= 2(y_1-y_0) - 2(x_1-x_0)(y_{i+1}-y_i) $$ （增量无浮点数运算）  
其中 $$y_{i+1}$$即第i+1个点的纵坐标，取决于$$P_i$$的符号。$$P_i<0$$则 $$(y_{i+1}-y_i)=0$$否则为1。  
带入 $$(x_0, y_0)$$ 可得:（初始值无浮点数运算）  
$$P_0 =  2(y_1-y_0) - (x_1-x_0)$$   
  
```  
y = y0  
dx = x1 - x0  
dy = y1 - y0  
p = 2*dy - dx  
for x = x0 to x1:  
  draw(x, y)  
  if p < 0:  
    p = p + 2*dy  
  else:  
    y = y + 1  
    p = p + 2*dy -2*dx  
```  
  
